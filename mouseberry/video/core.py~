import os
import threading
import time
import pickle

import picamera
import GPIO

import numpy as np
import h5py
import matplotlib.pyplot as plt


'''Ver1: Classical conditioning
exp = Experiment(n_trials=200, iti=np.random.exp(scale=1/20))
exp.add_video()
exp.add_measurement(name='licks', pin=6, sampling_rate=200)

trial_sm = Trial(name='trial_sm', p=0.5)
trial_sm.add_tone(name='tone_sm', f=10000, t_start=4, t_end=5)
trial_sm.add_rew(name='rew_sm', pin=5, vol=4, rate=40,
                    t_start=np.random.norm(loc=6, scale=1))
trial_sm.add_end_time(4)

trial_lg = Trial(name='trial_lg', p=0.5)
trial_lg.add_tone(name='tone_lg', f=5000, t_start=4, t_end=5)
trial_lg.add_rew(name='rew_lg', pin=5, vol=10, rate=40,
                    t_start=np.random.norm(loc=6, scale=1))
trial_lg.add_end_time(4)

trial_lg_airpuff = Trial(name='trial_lgrew_airpuff', p=0.5)
trial_lg_airpuff.add_tone(name='tone_lg', f=5000, t_start=4, t_end=5)
trial_lg_airpuff.add_rew(name='rew_lg', pin=5, vol=10, rate=40,
                    t_start=np.random.norm(loc=6, scale=1))
trial_lg_airpuff.add_stim(name='airpuff', pin=8, t_start=5,
t_end=5.5)
trial_lg_airpuff.add_end_time(4)

exp.run(trial_sm, trial_lg)
'''


'''Ver2: Operant conditioning
exp = Experiment(n_trials=200, iti=np.random.exp(scale=1/20))
exp.add_video()
exp.add_measurement(name='l_lickport', pin=5, sampling_rate=200)
exp.add_measurement(name='r_lickport', pin=6, sampling_rate=200)

l_trial = Trial(p=0.5)
l_trial.add_tone(name='high_tone', f=1000, t_start=4, t_end=5)
l_trial.add_rew(name='rew_large', pin=5, vol=4, rate=40,
                t_start=np.random.norm(loc=6, scale=1), 
                cond=l_trial.l_lickport.mean(t0=l_trial.high_tone.t_start, 
                                         t1=l_trial.high_tone.t_end)>4)

r_trial = Trial(p=0.5)
r_trial.add_tone(name='high_tone', f=1000, t_start=4, t_end=5)
r_trial.add_rew(name='rew_large', pin=5, vol=4, rate=40,
                t_start=np.random.norm(loc=6, scale=1), 
                cond=r_trial.l_lickport.mean(t0=r_trial.high_tone.t_start, 
                                         t1=r_trial.high_tone.t_end)>4)

exp.run(l_trial, r_trial)
# OR have an exp._magic_gather() function before exp.run()
'''

class Video():

    def __init__(self, res=(640, 480), framerate=30):
        """
        Creates an object to start a video stream on the local screen.
        """
        self.res = res
        self.framerate = framerate

    def preview(self):
        """
        Display a video preview from the rPi
        """
        self.camera = picamera.PiCamera()
        self.camera.resolution = self.res
        self.camera.framerate = self.framerate

        self.thread_prev = threading.Thread(target=self.camera.start_preview)
        self.thread_prev.start()

    def preview_and_rec(self, fname='my_vid.h264', folder='./'):
        """
        Display and record a video preview from the rPi
        """
        self.camera = picamera.PiCamera()
        self.camera.resolution = self.res
        self.camera.framerate = self.framerate

        fname_full = folder+fname
        self.thread_prev = threading.Thread(target=self.camera.start_preview)
        self.thread_rec = threading.Thread(target=self.camera.start_recording,
                                           args=(fname_full,))

        self.thread_prev.start()
        self.thread_rec.start()

    def stop_rec(self):
        self.thread_prev.join()
        self.thread_rec.join()
        self.camera.stop_recording


class Reward(object):
    """
    Create an object which delivers liquid rewards based on
    a particular GPIO pin.
    """
    def __init__(self, name, pin, io):
        self.name = name
        self.pin = pin
        self.io = io
        self.type = 'output'
        self.GPIOsetup()
        self._licks = []
        self._t_licks = []
        self.lickstep = 0
        self.num_samples = 0

    def __str__(self):
        return f'The {self.io} {self.name} associated to pin {self.pin}'

    def GPIOsetup(self):
        # Set up the GPIO pins you will be using as inputs or outputs
        GPIO.setup(self.pin, self.io)

    def deliver(self, size, rate=1):
        """
        Create a water reward stim.

        Parameters
        -----------
        size : float
            The size of reward (mL)
        rate : float
            Rate of flow (mL/sec)
        """

        # Calculate the reward_delay (duration of reward delivery)
        # based on the given parameters
        reward_delay = 1 / rate * size

        # Turn on the water dispenser
        GPIO.output(self.pin, True)

        # You'll have to account for the time it
        # takes for the water to get to the mouthpiece
        # Control the size of the reward
        time.sleep(reward_delay)

        # Turn off the water dispenser
        GPIO.output(self.pin, False)


class Measurement(object):
    """
    Create an object which measures
    a particular GPIO pin.
    """
    def __init__(self, name, pin, io):
        self.name = name
        self.pin = pin
        self.io = io
        self.type = 'input'
        self.GPIOsetup()
        self._licks = []
        self._t_licks = []
        self.lickstep = 0
        self.num_samples = 0

    def __str__(self):
        return f'The {self.io} {self.name} associated to pin {self.pin}'

    def GPIOsetup(self):
        # Set up the GPIO pins you will be using as inputs or outputs
        GPIO.setup(self.pin, self.io)

    def lick(self, sampling_rate, sampling_duration):
        # records the licks at a given sampling rate
        self._licks = []
        self._t_licks = []

        # calculate the number of samples needed
        self.num_samples = int(sampling_duration * sampling_rate)

        for i in range(self.num_samples):

            if GPIO.input(self.pin):
                # register lick
                self._licks.append(1)
                self._t_licks.append(time.time())

            else:
                # register no lick
                self._licks.append(0)
                self._t_licks.append(time.time())

            time.sleep(1 / sampling_rate)


class Tone():
    def __init__(self, frequency, tone_length):

        # Create a string that will be the name of the .wav file
        self.name = str(frequency) + 'Hz'
        self.freq = frequency

        # create a waveform called self.name from frequency and tone_length
        os.system(f'sox -V 0 -r 44100 -n -b 8 -c 2 '
                  + f'{self.name}.wav synth {tone_length} '
                  + f'sin {frequency} vol -10dB')

    def play(self):
        # send the wav file to the sound card
        os.system(f'play -V 0 -q {self.name}.wav')


class Data():
    def __init__(self, n_trials):
        '''
        Creates an instance of the class Data which will store parameters for
        each trial, including lick data and trial type information.

        Parameters
        -------
        n_trials  : int
            Specifies the number of trials to initialize


        Info
        --------
        self.t_experiment : str
            Stores the datetime where the behavior session starts

        self.t_start : np.ndarray
            Stores time of start for each trial

        self.tone : str
            Stores whether tone corresponded to 'l' or 'r'
        self.t_tone : np.ndarray
            Stores time of tone onset

        self.lick_r : dict
            A list of dictionaries where .lick_r[trial]['t'] stores the times
            of each measurement, and .lick_r[trial]['volt'] stores the voltage
            value of the measurement.
        self.v_rew_r : np.ndarray
            Stores reward volume
        self.t_rew_r : np.ndarray
            Stores time of reward onset
        '''

        self.t_experiment = time.strftime("%Y.%b.%d__%H:%M:%S",
                                          time.localtime(time.time()))
        self.t_start = np.empty(n_trials)  # start times of each trial
        self.t_end = np.empty(n_trials)

        self._t_start_abs = np.empty(n_trials)  # Internal var. storing abs.
        # start time in seconds for direct comparison with
        # time.time()

        self.tone = np.empty(n_trials, dtype=str)  # L or R
        self.t_tone = np.empty(n_trials)

        self.lick_r = np.empty(n_trials, dtype=dict)  # licks from R lickport
        self.lick_l = np.empty_like(self.lick_r)  # licks from L lickport

        self.v_rew_l = np.empty(n_trials)  # reward volumes from L lickport
        self.t_rew_l = np.empty(n_trials)  # reward times from L lickport
        self.v_rew_r = np.empty(n_trials)  # reward volumes from L lickport
        self.t_rew_r = np.empty(n_trials)  # reward times from L lickport

    def _pkl_store(self, filename=None):
        if filename is None:
            filename = str(mouse_number) + str(self.t_experiment) + '.pkl'

        with open(filename, 'wb') as f:
            pickle.dump(self, f)

    def store(self, filename=None):
        if filename is None:
            filename = str(mouse_number) + str(self.t_experiment) + '.hdf5'

        with h5py.File(filename, 'w') as f:
            # Set attributes of the file
            f.attrs['animal'] = mouse_number
            f.attrs['time_experiment'] = self.t_experiment
            f.attrs['user'] = os.getlogin()

            # Predefine variable-length dtype for storing t, volt
            dt = h5py.vlen_dtype(np.dtype('int32'))

            t_start = f.create_dataset('t_start', data=self.t_start)
            t_end = f.create_dataset('t_end', data=self.t_end)

            # Create data groups for licks, tones and rewards.
            lick_l = f.create_group('lick_l')
            lick_r = f.create_group('lick_r')

            tone = f.create_group('tone')

            rew_l = f.create_group('rew_l')
            rew_r = f.create_group('rew_r')

            # Preinitialize datasets for each sub-datatype within licks, tones
            # and rewards
            lick_l_t = lick_l.create_dataset('t', (n_trials,), dtype=dt)
            lick_l_volt = lick_l.create_dataset('volt', (n_trials,), dtype=dt)
            lick_r_t = lick_r.create_dataset('t', (n_trials,), dtype=dt)
            lick_r_volt = lick_r.create_dataset('volt', (n_trials,), dtype=dt)

            tone_t = tone.create_dataset('t', data=self.t_tone, dtype='f16')
            tone_type = tone.create_dataset('type', data=self.tone)

            rew_l_t = rew_l.create_dataset('t', data=self.t_rew_l)
            rew_l_v = rew_l.create_dataset('vol', data=self.v_rew_l)
            rew_r_t = rew_r.create_dataset('t', data=self.t_rew_r)
            rew_r_v = rew_r.create_dataset('vol', data=self.v_rew_r)

            for trial in range(n_trials):
                lick_l_t[trial] = self.lick_l[trial]['t']
                lick_l_volt[trial] = self.lick_l[trial]['volt']
                lick_r_t[trial] = self.lick_r[trial]['t']
                lick_r_t[trial] = self.lick_r[trial]['volt']

            # Finally, store metadata for each dataset/groups
            lick_l.attrs['title'] = 'Lick signal acquired from the left \
                lickport; contains times (s) and voltages (arb. units)'
            lick_r.attrs['title'] = 'Lick signal acquired from the right \
                lickport; contains times (s) and voltages (arb. units)'
            tone.attrs['title'] = 'Information about the delivered tones each \
                trial; contains times (s) and tone-type (a string denoting \
                whether the tone was large, small or nonexistent)'
            rew_l.attrs['title'] = 'Reward delivered to the left lickport; \
                contains time of reward (s) and its volume (uL)'
            rew_r.attrs['title'] = 'Reward delivered to the right lickport; \
                contains time of reward (s) and its volume (uL)'
            t_start.attrs['title'] = 'When the trial begins (s)'
            t_end.attrs['title'] = 'When the trial ends (s)'

    def plot(self, trial):
        '''
        parameters
        --------
        trial : int
            The trial to plot

        '''
        fig = plt.figure()
        ax = fig.add_subplot(1, 1, 1)
        ax.plot(self.lick_r[trial]['t'], self.lick_r[trial]['volt'], 'r')
        ax.plot(self.lick_l[trial]['t'], self.lick_l[trial]['volt'], 'g')

        ax.plot([self.t_tone, self.t_tone], [0, 5], 'k', linewidth=2)

        ax.plot([self.t_rew_l, self.t_rew_l], [0, 5], 'b', linewidth=2)
        ax.plot([self.t_rew_r, self.t_rew_r], [0, 5], 'b', linewidth=2)

        fig.savefig('data_plt.pdf')
